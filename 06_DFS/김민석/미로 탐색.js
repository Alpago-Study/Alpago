// [문제 이름]
// : 미로 탐색

// [문제 설명]
// : 7*7 격자판 미로를 탈출하는 경로의 가지수를 출력하는 프로그램을 작성하세요. 출발점은 격자의 (1, 1) 좌표이고, 탈출 도착점은 (7, 7)좌표이다. 격자판의 1은 벽이고, 0은 통로이다. 격자판의 움직임은 상하좌우로만 움직인다.

// 0 0 0 0 0 0 0
// 0 1 1 1 1 1 0
// 0 0 0 1 0 0 0
// 1 1 0 1 0 1 1
// 1 1 0 0 0 0 1
// 1 1 0 1 1 0 0
// 1 0 0 0 0 0 0

// 미로가 다음과 같다면 위의 지도에서 출발점에서 도착점까지 갈 수 있는 방법의 수는 8가지이다.

const solution = (map) => {
  let answer = 0; // 반환할 방법의 수
  const dx = [-1, 0, 1, 0]; // x 방향 배열
  const dy = [0, 1, 0, -1]; // y 방향 배열
  const destination = map.length - 1; // 도착지 (x, y가 각각 최대인 경우)

  // 1. DFS 함수 선언
  const DFS = (x, y) => {
    // 2-1. 만약 도착지에 도달했다면 (x, y 좌표 값이 각각 최대라면)
    // : 미로를 탐색할 수 있는 경우이므로 방법의 수 + 1
    if (x === destination && y === destination) {
      answer += 1;
    } else {
      // 2-1. 만약 아직 도착지에 도달하지 않았다면 현재 좌표에서 4방향으로 재귀 탐색
      for (let i = 0; i < dx.length; i++) {
        const newX = x + dx[i]; // 새로운 x 좌표 값
        const newY = y + dy[i]; // 새로운 y 좌표 값

        // 3-1. 새로운 x, y 좌표 값이 비정상적인 경우 무시
        if (newX < 0 || newY < 0 || newX > destination || newY > destination)
          continue;

        // 3-2. 새로운 좌표 값이 정상적이고, 해당 좌표의 값이 0인 경우 탐색 가능
        if (map[newX][newY] === 0) {
          // 4. 탐색을 진행했다는 의미로 좌표의 값을 1로 변경
          map[newX][newY] = 1;
          // 5. 재귀 호출
          DFS(newX, newY);
          // 6. 재귀 종료 시 다시 되돌아가야 하므로 좌표의 값을 다시 0으로 복구
          map[newX][newY] = 0;
        }
      }
    }
  };

  // 7. 출발지를 1로 설정 후 DFS 함수 호출
  map[0][0] = 1;
  DFS(0, 0);

  // 8. 누적된 탐색 방법의 수 반환
  return answer;
};

console.log(
  solution([
    [0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1, 0],
    [0, 0, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 0, 1, 1],
    [1, 1, 0, 0, 0, 0, 1],
    [1, 1, 0, 1, 1, 0, 0],
    [1, 0, 0, 0, 0, 0, 0],
  ])
);
