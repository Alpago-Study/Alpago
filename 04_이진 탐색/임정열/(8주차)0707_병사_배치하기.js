// [문제 이름]
// : 병사 배치하기

// [문제 설명]
// : 병사에 대한 정보가 주어졌을 때, 남아있는 병사의 수가 최대가 되도록 하기 위해서 열외해야 하는 병사의 수를 출력하는 프로그램을 작성하시오.

// [문제 링크]
// : https://www.acmicpc.net/problem/18353

/**
 * 이 문제는 LIS(Longest Increasing Subsequence, 최장 증가 부분 수열)를 사용해야 한다.
 *
 * 예시)
 * arr = [15, 11, 4, 8, 5, 2, 4];
 * dp  = [ 1,  1, 1, 1, 1, 1, 1];
 *
 * for문 (0부터 arr.length까지 / i는 기준이 되는 병사의 idx)
 *   for문 (0부터 기준이 되는 병사(i) 전까지 순회 / j는 비교하는 병사)
 *       기준 병사가 비교하는 병사보다 작을 경우 dp[i]를 늘린다!
 *
 * 예) i = 0 일 때 -> 안 for문 스킵
 *    i = 1 일 때 -> j = 0 / 기준 병사: 11 < 비교하는 병사: 15 -> dp[i] 늘리기
 *                  dp = [1, 2, 1, 1, 1, 1, 1]
 *
 *    i = 2 일 때 -> j = 0 / 기준 병사: 4 < 비교하는 병사: 15 -> dp[i] 늘리기
 *                  dp = [1, 2, 2, 1, 1, 1, 1]
 *               -> j = 1 / 기준 병사: 4 < 비교하는 병사: 11 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 1, 1, 1, 1]
 *
 *    i = 3 일 때 -> j = 0 / 기준 병사: 8 < 비교하는 병사: 15 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 2, 1, 1, 1]
 *               -> j = 1 / 기준 병사: 8 < 비교하는 병사: 11 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 1, 1, 1]
 *               -> j = 2 / 기준 병사: 8 > 비교하는 병사: 4 -> dp 변화 X
 *
 *    i = 4 일 때 -> j = 0 / 기준 병사: 5 < 비교하는 병사: 15 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 2, 1, 1]
 *               -> j = 1 / 기준 병사: 5 < 비교하는 병사: 11 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 3, 1, 1]
 *               -> j = 2 / 기준 병사: 5 > 비교하는 병사: 4 -> dp 변화 X
 *
 *               -> j = 3 / 기준 병사: 5 < 비교하는 병사: 8 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 1, 1]
 *
 *    i = 5 일 때 -> j = 0 / 기준 병사: 2 < 비교하는 병사: 15 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 2, 1]
 *               -> j = 1 / 기준 병사: 2 < 비교하는 병사: 11 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 3, 1]
 *               -> j = 2 / 기준 병사: 2 < 비교하는 병사: 4 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 4, 1]
 *               -> j = 3 / 기준 병사: 2 < 비교하는 병사: 8 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 4, 1]           * dp[j] = 3
 *               -> j = 4 / 기준 병사: 2 < 비교하는 병사: 5 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 5, 1]
 *
 *    i = 6 일 때 -> j = 0 / 기준 병사: 4 < 비교하는 병사: 15 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 2, 2]
 *               -> j = 1 / 기준 병사: 2 < 비교하는 병사: 11 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 3, 3]
 *               -> j = 2 / 기준 병사: 4 = 비교하는 병사: 4 -> dp 변화 X
 *
 *               -> j = 3 / 기준 병사: 4 < 비교하는 병사: 8 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 4, 4]           * dp[j] = 3
 *               -> j = 4 / 기준 병사: 4 < 비교하는 병사: 5 -> dp[i] 늘리기
 *                  dp = [1, 2, 3, 3, 4, 5, 5]
 *               -> j = 5 / 기준 병사: 4 > 비교하는 병사: 2 -> dp 변화 X
 *
 * dp 늘리는 기준
 * - dp[i] = max(dp[i], dp[j] + 1)
 *         => 즉, 본인의 기존 dp 값과 비교하는 병사의 dp 값 + 1 중 큰 값을 저장
 *
 * 즉, dp를 통해 알 수 있는 건 2개를 제외하면 내림차순으로 잘 정렬할 수 있다는 점!
 *
 * @param {number} soldierCnt  병사 수
 * @param {Array<number>} soldiers 병사 배열
 */
function solution(soldierCnt, soldiers) {
  // variables - 병사 배열
  let nums = soldiers;
  // variables - dp 테이블 - 모두 1로 초기화
  let dp = new Array(soldierCnt).fill(1);

  // i는 기준이 되는 병사의 idx
  // j는 기준이 되는 병사 전까지 순회
  for (let i = 0; i < soldierCnt; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] < nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }

  return soldierCnt - Math.max(...dp);
}

console.log(solution(7, [15, 11, 4, 8, 5, 2, 4]));
